import{_ as s,r as t,o as e,c as p,a as n,b as o,d as i,e as c}from"./app-0301958d.js";const l="/assets/2-773a7702.png",r="/assets/3-b3f7a8f9.png",u="/assets/4-18b3c93c.png",d="/assets/5-97c7d4d6.png",k="/assets/6-770bbe7b.png",g="/assets/7-93cf1532.png",m="/assets/8-3fcdf8fc.png",h="/assets/9-7fc6c3c4.png",b="/assets/10-1e4a1d5c.png",v="/assets/11-51ab3889.png",f="/assets/12-6ce00496.png",x={},y=c('<h1 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h1><blockquote><p>堆排序整个流程可以总结为：<code>上浮下沉</code></p></blockquote><h2 id="为什么解决本题需要用到堆" tabindex="-1"><a class="header-anchor" href="#为什么解决本题需要用到堆" aria-hidden="true">#</a> 为什么解决本题需要用到堆？</h2><blockquote><p>很多同学可能会想到这样一种解决，我把数组全部排序好，这样就可以拿到第k大的元素，这样是一种解法，但是我们是需要第K大的元素，<code>不一定要全部排序好再去拿，只针对部分元素进行排序</code>，这样的复杂度显然可以降低的</p></blockquote><p>也就是可以转化为：<strong>使用堆排序来解决这个问题——建立一个大顶堆，做k−1 次删除操作后,堆顶元素就是我们要找的答案</strong><code>（堆排序过程中，不全部下沉，下沉</code>nums.length-k+1<code>,然后堆顶可以拿到我们top k答案了）</code></p><h2 id="基本介绍" tabindex="-1"><a class="header-anchor" href="#基本介绍" aria-hidden="true">#</a> 基本介绍</h2><p>堆排序是利用 <strong>堆</strong> 这种 <strong>数据结构</strong> 而设计的一种排序算法，它是一种选择排序，最坏 、最好、平均时间复杂度均为 <code>O(nlogn)</code>，它是不稳定排序。</p><blockquote><p>注意因为完全二叉树的性质，可以用数组表示对应的树结构（所以，堆排序过程中，你是看不到树这数据结构的，用数组进行映射了），这叫<code>顺序存储</code></p></blockquote><h2 id="顺序存储二叉树" tabindex="-1"><a class="header-anchor" href="#顺序存储二叉树" aria-hidden="true">#</a> 顺序存储二叉树</h2><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ul><li>第 n 个元素的 左子节点 为 <strong>2*n+1</strong></li><li>第 n 个元素的 右子节点 为 <strong>2*n+2</strong></li><li>第 n 个元素的 父节点 为 <strong>(n-1)/2</strong></li><li>最后一个非叶子节点为 <strong>Math.floor(arr.length/2)-1</strong></li></ul><p>堆是具有以下性质的完全二叉树：</p><ul><li><p>大顶堆：每个节点的值都 <strong>大于或等于</strong> 其左右孩子节点的值</p><p>注：<strong>没有要求左右值的大小关系</strong></p></li><li><p>小顶堆：每个节点的值都 <strong>小于或等于</strong> 其左右孩子节点的值</p></li></ul><p>举例说明：</p><h3 id="大顶堆举例" tabindex="-1"><a class="header-anchor" href="#大顶堆举例" aria-hidden="true">#</a> 大顶堆举例</h3><figure><img src="'+l+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>对堆中的节点按层进行编号，映射到数组中如下图</p><figure><img src="'+r+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>大顶堆特点：<code>arr[i] &gt;= arr[2*i+1] &amp;&amp; arr[i] &gt;= arr[2*i+2]</code>，i 对应第几个节点，i 从 0 开始编号</p><h3 id="小顶堆举例" tabindex="-1"><a class="header-anchor" href="#小顶堆举例" aria-hidden="true">#</a> 小顶堆举例</h3><figure><img src="'+u+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>小顶堆特点：<code>arr[i] &lt;= arr[2*i+1] &amp;&amp; arr[i] &lt;= arr[2*i+2]</code>，i 对应第几个节点，i 从 0 开始</p><h3 id="排序说明" tabindex="-1"><a class="header-anchor" href="#排序说明" aria-hidden="true">#</a> 排序说明</h3><ul><li>升序：一般采用大顶堆</li><li>降序：一般采用小顶堆</li></ul><h2 id="基本思想" tabindex="-1"><a class="header-anchor" href="#基本思想" aria-hidden="true">#</a> 基本思想</h2><ol><li><p>将待排序序列构造成一个大顶堆</p><p>注意：这里使用的是数组，而不是一颗二叉树</p></li><li><p>此时：整个序列的 <strong>最大值就是堆顶的根节点</strong></p></li><li><p>将其 <strong>与末尾元素进行交换</strong>，此时末尾就是最大值</p></li><li><p>然后将剩余 <code>n-1</code> 个元素重新构造成一个堆，这样 就会得到 n 个元素的次小值。如此反复，便能的得到一个有序序列。</p></li></ol><h2 id="堆排序步骤图解" tabindex="-1"><a class="header-anchor" href="#堆排序步骤图解" aria-hidden="true">#</a> 堆排序步骤图解</h2><p>对数组 <code>4,6,8,5,9</code> 进行堆排序，将数组升序排序。</p><h3 id="步骤一-构造初始堆" tabindex="-1"><a class="header-anchor" href="#步骤一-构造初始堆" aria-hidden="true">#</a> 步骤一：构造初始堆</h3><ol><li>给定无序序列结构 如下：注意这里的操作用数组，树结构只是参考理解</li></ol><figure><img src="'+d+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>将给定无序序列构造成一个大顶堆。</p><ol start="2"><li><strong>此时从最后一个非叶子节点开始调整</strong>，从左到右，从上到下进行调整。</li></ol><p>叶节点不用调整，第一个非叶子节点 <code>arr.length/2-1 = 5/2-1 = 1 </code>，也就是 元素为 6 的节点。</p><pre><code>比较时：先让 5 与 9 比较，得到最大的那个，再和 6 比较，发现 9 大于 6，则调整他们的位置。
</code></pre><p><img src="`+k+'" alt="image.png" loading="lazy"> 3. 找到第二个非叶子节点 4，由于 <code>[4,9,8]</code> 中，9 元素最大，则 4 和 9 进行交换</p><figure><img src="'+g+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="4"><li>此时，交换导致了子根 <code>[4,5,6]</code> 结构混乱，将其继续调整。<code>[4,5,6]</code> 中 6 最大，将 4 与 6 进行调整。</li></ol><figure><img src="'+m+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><p>此时，就将一个无序序列构造成了一个大顶堆。</p><h3 id="步骤二-将堆顶元素与末尾元素进行交换" tabindex="-1"><a class="header-anchor" href="#步骤二-将堆顶元素与末尾元素进行交换" aria-hidden="true">#</a> 步骤二：将堆顶元素与末尾元素进行交换</h3><p>将堆顶元素与末尾元素进行交换，<strong>使其末尾元素最大</strong>。然后继续调整，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</p><ol><li>将堆顶元素 9 和末尾元素 4 进行交换</li></ol><figure><img src="'+h+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="2"><li>重新调整结构，使其继续满足堆定义</li></ol><figure><img src="'+b+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="3"><li>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8</li></ol><figure><img src="'+v+'" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol start="4"><li>后续过程，继续进行调整、交换，如此反复进行，最终使得整个序列有序</li></ol><figure><img src="'+f+`" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="总结思路" tabindex="-1"><a class="header-anchor" href="#总结思路" aria-hidden="true">#</a> 总结思路</h3><ol><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素「沉」到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶与当前末尾元素，反复执行调整、交换步骤，直到整个序列有序。</li></ol><h3 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤" aria-hidden="true">#</a> 步骤</h3><p>这里想说的几点注意事项（代码实现的关键思路）：</p><ol><li><p>第一步构建初始堆：<strong>是自底向上构建，从最后一个非叶子节点开始</strong>。</p></li><li><p>第二步就是<code>下沉操作</code>让尾部元素与堆顶元素交换，<strong>最大值被放在数组末尾</strong>，并且缩小数组的length，不参与后面大顶堆的调整</p></li><li><p>第三步就是<code>调整</code>：<strong>是从上到下，从左到右</strong>,因为堆顶元素下沉到末尾了，要重新调整这颗大顶堆</p></li></ol><h3 id="代码模板" tabindex="-1"><a class="header-anchor" href="#代码模板" aria-hidden="true">#</a> 代码模板</h3><blockquote><p>官方的代码模板我参考了下，比一些书籍写的都好记，所以可以参考作为堆排序的模板</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">nums</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">k</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
 <span class="token comment">// 整个流程就是上浮下沉</span>
<span class="token keyword">var</span> <span class="token function-variable function">findKthLargest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> heapSize<span class="token operator">=</span>nums<span class="token punctuation">.</span>length
    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span> <span class="token comment">// 构建好了一个大顶堆</span>
    <span class="token comment">// 进行下沉 大顶堆是最大元素下沉到末尾</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>
        <span class="token operator">--</span>heapSize <span class="token comment">// 下沉后的元素不参与到大顶堆的调整</span>
        <span class="token comment">// 重新调整大顶堆</span>
         <span class="token function">maxHeapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
   <span class="token comment">// 自下而上构建一颗大顶堆</span>
   <span class="token keyword">function</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span>heapSize</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>heapSize<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">maxHeapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 从左向右，自上而下的调整节点</span>
   <span class="token keyword">function</span> <span class="token function">maxHeapify</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>heapSize</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">let</span> l<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span>
       <span class="token keyword">let</span> r<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">2</span>
       <span class="token keyword">let</span> largest<span class="token operator">=</span>i
       <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           largest<span class="token operator">=</span>l
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           largest<span class="token operator">=</span>r
       <span class="token punctuation">}</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>largest<span class="token operator">!==</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>largest<span class="token punctuation">)</span> <span class="token comment">// 进行节点调整</span>
           <span class="token comment">// 继续调整下面的非叶子节点</span>
           <span class="token function">maxHeapify</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>largest<span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>  i<span class="token punctuation">,</span>  j</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="进行堆排序" tabindex="-1"><a class="header-anchor" href="#进行堆排序" aria-hidden="true">#</a> 进行堆排序</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">findKthLargest</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
<span class="token comment">// 或者调整一下 let i=nums.length-1;i&gt;=nums.length-k+1;的条件就行</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复杂度" tabindex="-1"><a class="header-anchor" href="#复杂度" aria-hidden="true">#</a> 复杂度</h2><table><thead><tr><th>名称</th><th style="text-align:center;">最佳情况</th><th style="text-align:center;">平均情况</th><th style="text-align:center;">最坏情况</th><th style="text-align:center;">内存</th><th style="text-align:center;">稳定性</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td><strong>堆排序</strong></td><td style="text-align:center;">n log(n)</td><td style="text-align:center;">n log(n)</td><td style="text-align:center;">n log(n)</td><td style="text-align:center;">1</td><td style="text-align:center;">否</td><td style="text-align:left;"></td></tr></tbody></table><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,63),_={href:"https://en.wikipedia.org/wiki/Heapsort",target:"_blank",rel:"noopener noreferrer"};function w(z,S){const a=t("ExternalLinkIcon");return e(),p("div",null,[y,n("p",null,[n("a",_,[o("维基百科"),i(a)])])])}const q=s(x,[["render",w],["__file","index.html.vue"]]);export{q as default};
