import{_ as c,r as n,o as t,c as s,a as e,b as a,e as o,d as r}from"./app-2d6feb9f.js";const i={},l=r(`<h1 id="正则表达式匹配" tabindex="-1"><a class="header-anchor" href="#正则表达式匹配" aria-hidden="true">#</a> 正则表达式匹配</h1><p>给定一个输入字符串 <code>s</code> 和一个模式 <code>p</code>，实现支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。</p><ul><li><code>.</code> 匹配任意单个字符。</li><li><code>*</code> 匹配零个或多个前面的元素。</li></ul><p>匹配应覆盖<strong>整个</strong>输入字符串（不是部分匹配）。</p><p><strong>注意</strong></p><ul><li><code>s</code> 可能为空，且只包含小写字母 <code>a-z</code>。</li><li><code>p</code> 可能为空，且只包含小写字母 <code>a-z</code>，以及字符 <code>.</code> 或 <code>*</code>。</li></ul><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h2><p><strong>示例 1</strong></p><p>输入:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>s = &#39;aa&#39;
p = &#39;a&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出: <code>false</code></p><p>解释: <code>a</code> 与字符串 <code>aa</code> 不完全匹配。</p><p><strong>示例 2</strong></p><p>输入:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>s = &#39;aa&#39;
p = &#39;a*&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出: <code>true</code></p><p>解释: <code>*</code> 表示前面的元素 <code>a</code> 的零个或多个。因此，通过重复 <code>a</code> 一次，它变为 <code>aa</code>。</p><p><strong>示例 3</strong></p><p>输入:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>s = &#39;ab&#39;
p = &#39;.*&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出: <code>true</code></p><p>解释: <code>.*</code> 表示 &quot;零个或多个 (<code>*</code>) 任意字符 (<code>.</code>)&quot;。</p><p><strong>示例 4</strong></p><p>输入:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>s = &#39;aab&#39;
p = &#39;c*a*b&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出: <code>true</code></p><p>解释: <code>c</code> 可以重复 0 次，<code>a</code> 可以重复 1 次。因此，它与 <code>aab</code> 匹配。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,28),p={href:"https://www.youtube.com/watch?v=l3hda49XcDE&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=71&t=0s",target:"_blank",rel:"noopener noreferrer"},u={href:"https://leetcode.com/problems/regular-expression-matching/description/",target:"_blank",rel:"noopener noreferrer"};function h(v,g){const d=n("ExternalLinkIcon");return t(),s("div",null,[l,e("ul",null,[e("li",null,[e("a",p,[a("YouTube"),o(d)])]),e("li",null,[e("a",u,[a("LeetCode"),o(d)])])])])}const b=c(i,[["render",h],["__file","index.html.vue"]]);export{b as default};
