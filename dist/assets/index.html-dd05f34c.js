import{_ as n,r as c,o as i,c as t,a as e,b as a,e as o,d as r}from"./app-2d6feb9f.js";const s={},l=r(`<h1 id="z-算法" tabindex="-1"><a class="header-anchor" href="#z-算法" aria-hidden="true">#</a> Z 算法</h1><p>Z 算法用于在线性时间 <code>O(|W| + |T|)</code> 内查找主字符串 <code>T</code> 中的一个单词 <code>W</code> 的出现位置。</p><p>给定长度为 <code>n</code> 的字符串 <code>S</code>，该算法产生一个数组 <code>Z</code>，其中 <code>Z[i]</code> 表示以 <code>S[i]</code> 开头的最长子串，该子串也是 <code>S</code> 的前缀。通过计算在单词 <code>W</code> 后连接一个特殊字符（例如 <code>$</code>）和文本 <code>T</code> 后所得到的字符串的 <code>Z</code> 数组，可以帮助进行模式匹配。如果存在某个索引 <code>i</code>，使得 <code>Z[i]</code> 等于模式的长度，则该模式必定存在于该位置。</p><p>尽管可以使用两层嵌套循环以 <code>O(|W| * |T|)</code> 的时间计算 <code>Z</code> 数组，但下面的策略展示了如何在线性时间内获得 <code>Z</code> 数组。其基本思想是，当我们迭代字符串中的字母时（索引从 <code>1</code> 到 <code>n-1</code>），我们维护一个区间 <code>[L, R]</code>，它是具有最大 <code>R</code> 的区间，使得 <code>1 ≤ L ≤ i ≤ R</code> 且 <code>S[L...R]</code> 是一个同时是前缀和子串的字符串（如果不存在这样的区间，则令 <code>L = R = -1</code>）。对于 <code>i = 1</code>，我们可以通过比较 <code>S[0...]</code> 和 <code>S[1...]</code> 来计算 <code>L</code> 和 <code>R</code>。</p><p><strong>Z 数组示例</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Index            0   1   2   3   4   5   6   7   8   9  10  11 
Text             a   a   b   c   a   a   b   x   a   a   a   z
Z values         X   1   0   0   3   1   0   0   2   2   1   0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其他示例</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>str =  a a a a a a
Z[] =  x 5 4 3 2 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>str =  a a b a a c d
Z[] =  x 1 0 2 1 0 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>str =  a b a b a b a b
Z[] =  x 0 6 0 4 0 2 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Z 盒子示例</strong></p><figure><img src="https://ivanyu.me/wp-content/uploads/2014/09/zalg1.png" alt="z-box" tabindex="0" loading="lazy"><figcaption>z-box</figcaption></figure><h2 id="复杂度" tabindex="-1"><a class="header-anchor" href="#复杂度" aria-hidden="true">#</a> 复杂度</h2><ul><li><strong>时间复杂度：</strong><code>O(|W| + |T|)</code></li><li><strong>空间复杂度：</strong><code>O(|W|)</code></li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,15),u={href:"https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.youtube.com/watch?v=CpZh4eF8QBw&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=70",target:"_blank",rel:"noopener noreferrer"},g={href:"https://ivanyu.me/blog/2013/10/15/z-algorithm/",target:"_blank",rel:"noopener noreferrer"};function v(p,b){const d=c("ExternalLinkIcon");return i(),t("div",null,[l,e("ul",null,[e("li",null,[e("a",u,[a("GeeksForGeeks"),o(d)])]),e("li",null,[e("a",h,[a("YouTube"),o(d)])]),e("li",null,[e("a",g,[a("Ivan Yurchenko 的 Z 算法文章"),o(d)])])])])}const x=n(s,[["render",v],["__file","index.html.vue"]]);export{x as default};
