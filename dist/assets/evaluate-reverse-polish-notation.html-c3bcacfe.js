import{_ as n,o as s,c as a,d as t}from"./app-2477bd15.js";const p={},e=t(`<h1 id="逆波兰表达式求值" tabindex="-1"><a class="header-anchor" href="#逆波兰表达式求值" aria-hidden="true">#</a> <strong>逆波兰表达式求值</strong></h1><p>给定一个逆波兰表达式，计算其值。逆波兰表达式是一种无括号的数学表达式表示法，其中运算符跟随在操作数之后。</p><p><strong>示例：</strong></p><p>输入：tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] 输出：9 解释：逆波兰表达式 &quot;2 1 + 3 *&quot; 对应的计算过程为：(2 + 1) * 3 = 9。</p><p>输入：tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] 输出：6 解释：逆波兰表达式 &quot;4 13 5 / +&quot; 对应的计算过程为：4 + (13 / 5) = 6。</p><h2 id="题目分析与解题步骤" tabindex="-1"><a class="header-anchor" href="#题目分析与解题步骤" aria-hidden="true">#</a> <strong>题目分析与解题步骤：</strong></h2><p>这个问题可以使用栈来实现逆波兰表达式的求值。我们可以遍历逆波兰表达式，遇到操作数时将其压入栈中，遇到运算符时从栈中弹出操作数进行计算，并将计算结果再次压入栈中，直到遍历完整个表达式，最后栈中的元素即为最终的结果。</p><p>解题步骤如下：</p><ol><li><p>创建一个栈<code>stack</code>，用于存储操作数。</p></li><li><p>遍历逆波兰表达式<code>tokens</code>，并执行以下操作：</p><ul><li><p>如果当前元素是操作数，将其转换为数值并压入栈<code>stack</code>中。</p></li><li><p>如果当前元素是运算符，从栈<code>stack</code>中弹出两个操作数，根据当前运算符进行计算，并将计算结果压入栈<code>stack</code>中。</p></li></ul></li><li><p>遍历完整个表达式后，栈<code>stack</code>中仅剩一个元素，即为最终的结果。</p></li><li><p>返回栈<code>stack</code>中的唯一元素作为逆波兰表达式的计算结果。</p></li></ol><h2 id="javascript解题框架" tabindex="-1"><a class="header-anchor" href="#javascript解题框架" aria-hidden="true">#</a> <strong>JavaScript解题框架：</strong></h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">evaluateReversePolishNotation</span><span class="token punctuation">(</span><span class="token parameter">tokens</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> token <span class="token keyword">of</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isNaN</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 操作数</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 运算符</span>
      <span class="token keyword">let</span> operand2 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> operand1 <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> result<span class="token punctuation">;</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&#39;+&#39;</span><span class="token operator">:</span>
          result <span class="token operator">=</span> operand1 <span class="token operator">+</span> operand2<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&#39;-&#39;</span><span class="token operator">:</span>
          result <span class="token operator">=</span> operand1 <span class="token operator">-</span> operand2<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&#39;*&#39;</span><span class="token operator">:</span>
          result <span class="token operator">=</span> operand1 <span class="token operator">*</span> operand2<span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&#39;/&#39;</span><span class="token operator">:</span>
          result <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">trunc</span><span class="token punctuation">(</span>operand1 <span class="token operator">/</span> operand2<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个框架中，我们首先定义了一个栈类<code>Stack</code>，其中包含了常用的栈操作方法。然后，我们使用栈来实现逆波兰表达式的求值。</p><p>在<code>evaluateReversePolishNotation</code>函数中，我们遍历逆波兰表达式<code>tokens</code>，根据当前元素的类型进行相应的操作。如果当前元素是操作数，则将其转换为数值并压入栈中。如果当前元素是运算符，则从栈中弹出两个操作数，进行计算，并将计算结果压入栈中。</p><p>最后，返回栈中的唯一元素作为逆波兰表达式的计算结果。</p>`,14),o=[e];function c(l,i){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","evaluate-reverse-polish-notation.html.vue"]]);export{r as default};
